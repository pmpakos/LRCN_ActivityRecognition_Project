from keras.preprocessing.image import ImageDataGenerator
from keras.preprocessing import image
from keras import backend as K

import numpy as np
import matplotlib.pyplot as plt

def preprocess_input(x, data_format=None):
    """Preprocesses a tensor encoding an image.
    # Arguments
        x: input Numpy tensor, 3D.
        data_format: data format of the image.
    # Returns
        Preprocessed tensor.
    """
    if data_format is None:
        data_format = K.image_data_format()
    assert data_format in {'channels_last', 'channels_first'}

    if data_format == 'channels_first':
        # 'RGB'->'BGR'
        x = x[::-1, :, :]*1.0
        # Zero-center by mean pixel
        x[0, :, :] -= 103.939
        x[1, :, :] -= 116.779
        x[2, :, :] -= 123.68
    else:
        # 'RGB'->'BGR'
        x = x[:, :, ::-1]*1.0
        # Zero-center by mean pixel
        x[:, :, 0] -= 103.939
        x[:, :, 1] -= 116.779
        x[:, :, 2] -= 123.68
    return x

def preprocess_input_flow(x, data_format=None):
    """Preprocesses a tensor encoding an image.
    # Arguments
        x: input Numpy tensor, 3D.
        data_format: data format of the image.
    # Returns
        Preprocessed tensor.
    """
    if data_format is None:
        data_format = K.image_data_format()
    assert data_format in {'channels_last', 'channels_first'}

    if data_format == 'channels_first':
        # 'RGB'->'BGR'
        x = x[::-1, :, :]*1.0
        # Zero-center by mean pixel
        x[0, :, :] -= 128.0
        x[1, :, :] -= 128.0
        x[2, :, :] -= 128.0
    else:
        # 'RGB'->'BGR'
        x = x[:, :, ::-1]*1.0
        # Zero-center by mean pixel
        x[:, :, 0] -= 128.0
        x[:, :, 1] -= 128.0
        x[:, :, 2] -= 128.0
    return x

# Support for random cropping ImageDataGenerator 
# https://jkjung-avt.github.io/keras-image-cropping/
def random_crop(img, crop_width, crop_height):
    # Note: image_data_format is 'channel_last'
    assert img.shape[2] == 3
    height, width = img.shape[0], img.shape[1]
    dx, dy = crop_width, crop_height
    x = np.random.randint(0, width - dx + 1)
    y = np.random.randint(0, height - dy + 1)
    return img[y:(y+dy), x:(x+dx), :]

def center_crop(img, crop_width, crop_height):
    # Note: image_data_format is 'channel_last'
    assert img.shape[2] == 3
    height, width = img.shape[0], img.shape[1]
    dx, dy = crop_width, crop_height
    x = width//2 - dx//2
    y = height//2 - dy//2
    return img[y:(y+dy), x:(x+dx), :]


def crop_generator(batches, crop_width, crop_height,random):
    '''
    Take as input a Keras ImageGen (Iterator) and generate random
    crops from the image batches generated by the original iterator
    '''
    while True:
        batch_x, batch_y = next(batches)
        batch_crops = np.zeros((batch_x.shape[0], crop_width, crop_height, 3))
        if(random==True):
            for i in range(batch_x.shape[0]):
                batch_crops[i] = random_crop(batch_x[i], crop_width, crop_height)
        else:
            for i in range(batch_x.shape[0]):
                batch_crops[i] = center_crop(batch_x[i], crop_width, crop_height)
        yield (batch_crops, batch_y)


def print_examples(image_crops, batch_size, classes_dictionary):
    x_batch, y_batch = next(image_crops)
    for i in range(0,batch_size):
        img = x_batch[i]
        img = (img-img.min())/(img.max()-img.min())
        plt.figure(figsize=(5,5))
        plt.imshow(img)
        plt.title(classes_dictionary[y_batch[i].argmax()])
